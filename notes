(*) Singleton: a design pattern that ensures that only one instance of a class, that can be instanciated
in the entire application. to implement this in c++, all the constructors shall be private
to ensure that the class cannot be instanciated outside of its declaration or definition.
then declare a function with a static variable (static Class object;) that returns always the same static object.
Go to learn.cpp file to find a very easy example.

(*) Multiplicity in uml represents how many instances of a class can be connected to an 
instance of another class.
    => for aggregation and composition the multiplicity string which is next to the diamond specifies how many containing instance can have the same contained instance
    and the one which is next to the contained class represents how many instances of the contained class are contained by one instance of the containing class. (for aggregation we use collecting and collected, instead of containing and contained)
    => for aggregation between an interface and another class: the uml tool i used didn't support this type of relationship, so i used association arrow (0---0..1) to represent aggregation, since the latter is a special case of the former.

    => for composition, the upper string is at least 1 (simply because every instance of the composite class has at least one instance of the contained class, in all cases of composition).
    => for aggregation, the upper string is at least 0 (simply because every instance of the collecting class can have 0 or more instances of the contained classes).

(*) Dependency relationship: In every composition, aggregation (or generally            association) relationship case, there is at least one dependency relationship.
    so it is redundant to add an arrow representing dependency.
    But in the case where a class is neither containing nor collecting an object of another class, but still use it in its implementation (it could be a parameter of a method for example), it is important to represent the dependency relationship between the two, since the first class is depending in its implementation of the second class. a use relationship is also applicable in the lsat case.

(*) I used implementation arrow to represent inheritance between the LinkablePart interface and non-interface classes (non-interface means that these classes will implement the interface, not just extend it).

(*) Advice: if you decide using the same site i used (see resources), when you're done choose extracting your diagram with JPEG not PNG, don't worry the output file will be in PNG format even if you specified JPEG, it may look to you like a bug, but it's a life saving feature for me, because the output will be much better than if you choose extracting with PNG.